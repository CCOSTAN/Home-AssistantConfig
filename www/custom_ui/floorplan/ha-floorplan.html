<!--
    Floorplan for Home Assistant
    Version: 1.0.7.26
    By Petar Kozul
    https://github.com/pkozul/ha-floorplan
  -->

<script src="lib/jquery-3.2.1.min.js"></script>
<script src="lib/moment.min.js"></script>
<script src="lib/yaml.min.js"></script>

<!-- As documented here for Google Chrome, removes the need for touchstart -->
<meta name="viewport" content="width=device-width">

<dom-module id="ha-floorplan">

  <template>
    <style>
      .loading-container {
        text-align: center;
        padding: 8px;
      }

      .loading {
        height: 0px;
        overflow: hidden;
      }

      #log {
        max-height: 150px;
        overflow: auto;
        background-color: #eee;
        display: none;
        padding: 10px;
      }

      #log ul {
        list-style-type: none;
        padding-left: 0px;
      }

      .error {
        color: #FF0000;
      }

      .warning {
        color: #FF851B;
      }

      .info {
        color: #0000FF;
      }

      .debug {
        color: #000000;
      }
    </style>

    <template is='dom-if' if='[[isLoading]]'>
      <div class='loading-container'>
        <paper-spinner active alt='Loading'></paper-spinner>
      </div>
    </template>

    <div id="log">
      <a href="#" onclick="$(this).siblings('ul').html('').parent().css('display', 'none');">Clear log</a>
      <ul></ul>
    </div>

    <div id="floorplan" on-tap="stopPropagation"></div>

  </template>

</dom-module>

<script>
  Polymer({
    is: 'ha-floorplan',

    ready() {
      this.onReady();
    },

    attached() {
      this.onAttached();
    },

    detached() {
    },

    properties: {
      version: {
        type: String,
        value: '1.0.7.26',
      },
      hass: {
        type: Object,
        observer: 'hassChanged'
      },
      inDialog: {
        type: Boolean,
        value: false,
      },
      isPanel: {
        type: Boolean,
        value: false,
      },
      _config: {
        type: Object,
      },
      config: {
        type: Object,
      },
      isLoading: {
        type: Boolean,
        value: true,
      },
      timeDifference: {
        type: Number,
        value: undefined,
      },
      pageInfos: {
        type: Array,
        value: () => { return []; },
      },
      entityInfos: {
        type: Array,
        value: () => { return []; },
      },
      elementInfos: {
        type: Array,
        value: () => { return []; },
      },
      cssRules: {
        type: Array,
        value: () => { return []; },
      },
      entityTransitions: {
        type: Array,
        value: () => { return []; },
      },
      lastMotionConfig: {
        type: Array,
        value: () => { return []; }
      },
      logLevels: {
        type: Array,
        value: () => { return []; },
      },
      handleEntitiesDebounced: {
        type: Object,
        value: () => { return () => { } },
      },
    },

    stopPropagation(e) {
      e.stopPropagation();
    },

    hassChanged(newHass, oldHass) {
      if (!this.config) {
        return;
      }

      this.handleEntitiesDebounced(); // use debounced wrapper
    },

    /***************************************************************************************************************************/
    /* Startup
    /***************************************************************************************************************************/

    onReady() {
      this.handleEntitiesDebounced = this.debounce(() => {
        this.handleEntities(this.hass.states);
      }, 100);
    },

    onAttached() {
      window.onerror = this.handleWindowError.bind(this);

      this.initTimeDifference();

      ((this._config && this._config.config) ? this.loadConfig(this._config.config) : Promise.resolve(this._config))
        .then(config => {
          this.config = config;

          this.logInfo(`Floorplan v${this.version}`);

          this.getLogLevels();

          if (!this.validateConfig(this.config)) {
            this.isLoading = false;
            return Promise.resolve();
          }

          return this.loadLibraries()
            .then(() => {
              this.initFullyKiosk();
              return this.config.pages ? this.initMultiPage() : this.initStandard();
            });
        })
        .catch(error => {
          this.isLoading = false;
          this.handleError(error);
        });
    },

    initMultiPage() {
      return this.loadPages()
        .then(() => {
          this.isLoading = false;
          return this.handleEntities(this.hass.states, true)
            .then(() => {
              this.initPageDisplay();
              return Promise.resolve();
            });
        });
    },

    initStandard() {
      return this.loadSvg(this.config.image)
        .then((svg) => {
          this.config.svg = svg;
          return this.loadStyleSheet(this.config.stylesheet)
            .then(() => {
              return Promise.resolve(this.initSvg(svg, this.config))
                .then(() => {
                  this.isLoading = false;
                  return this.handleEntities(this.hass.states, true)
                    .then(() => {
                      this.initPageDisplay();
                      return Promise.resolve();
                    });
                })
            });
        });
    },

    getLogLevels() {
      if (!this.config.log_level) {
        return;
      }

      let allLogLevels = {
        error: ['error'],
        warning: ['error', 'warning'],
        info: ['error', 'warning', 'info'],
        debug: ['error', 'warning', 'info', 'debug'],
      };

      this.logLevels = allLogLevels[this.config.log_level.toLowerCase()];
    },

    /***************************************************************************************************************************/
    /* Loading resources
    /***************************************************************************************************************************/

    loadConfig(configUrl) {
      return this.getResource(configUrl, false)
        .then(config => {
          return Promise.resolve(yaml.load(config));
        });
    },

    loadLibraries() {
      let promises = [];

      if (this.isOptionEnabled(this.config.pan_zoom)) {
        promises.push(this.loadScript('/local/custom_ui/floorplan/lib/svg-pan-zoom.min.js'));
      }

      if (this.isOptionEnabled(this.config.fully_kiosk)) {
        promises.push(this.loadScript('/local/custom_ui/floorplan/lib/fully-kiosk.js'));
      }

      return promises.length ? Promise.all(promises) : Promise.resolve();
    },

    loadScript(scriptUrl) {
      return new Promise((resolve, reject) => {
        let script = document.createElement('script');
        script.src = this.cacheBuster(scriptUrl);
        script.onload = () => {
          return resolve();
        };
        script.onerror = (err) => {
          reject(new URIError(`${err.target.src}`));
        };

        Polymer.dom(this.root).appendChild(script);
      });
    },

    loadPages() {
      let defaultPageConfigUrl = this.config.pages.length ? this.config.pages[0] : undefined; // default page

      let promises = this.config.pages.map(pageConfigUrl =>
        this.loadPage(pageConfigUrl, (pageConfigUrl === defaultPageConfigUrl)));
      return promises.length ? Promise.all(promises) : Promise.resolve();
    },

    loadPage(pageConfigUrl, isDefault) {
      return this.loadConfig(pageConfigUrl)
        .then((pageConfig) => {
          let pageInfo = this.createPageInfo(pageConfig);
          pageInfo.isDefault = isDefault;
          return this.loadSvg(pageInfo.config.image)
            .then((svg) => {
              pageInfo.svg = svg;
              return this.loadStyleSheet(pageInfo.config.stylesheet)
                .then(() => {
                  return Promise.resolve(this.initSvg(pageInfo.svg, pageInfo.config));
                });
            });
        });
    },

    createPageInfo(pageConfig, isDefault) {
      let pageInfo = { config: pageConfig };

      // Merge the page's groups with the main config's groups
      if (pageInfo.config.groups && this.config.groups) {
        pageInfo.config.groups = pageInfo.config.groups.concat(this.config.groups);
      }

      this.pageInfos[pageInfo.config.page_id] = pageInfo;

      return pageInfo;
    },

    loadStyleSheet(stylesheetUrl) {
      return new Promise((resolve, reject) => {
        if (!stylesheetUrl) {
          return resolve();
        }

        this.loadStyleSheetInternal(stylesheetUrl, function (success, link) {
          if (success && link && link.sheet && link.sheet.cssRules) {
            Polymer.dom(this.instance.root).appendChild(link);
            let styleSheet = link.sheet;
            this.instance.cssRules = this.instance.cssRules.concat(this.instance.getArray(styleSheet.cssRules));
            return this.resolve();
          }
          else {
            reject(new URIError(`${stylesheetUrl}`));
          }
        }.bind({ instance: this, resolve: resolve, reject: reject }));
      });
    },

    loadSvg(imageUrl) {
      return this.getResource(imageUrl, true)
        .then(result => {
          let svg = $(result).find('svg')[0];

          $(svg).height('100%');
          $(svg).width('100%');
          $(svg).css('position', this.isPanel ? 'absolute' : 'relative');
          $(svg).css('cursor', 'default');
          $(svg).css('opacity', 0);

          Polymer.dom(this.$.floorplan).node.appendChild(svg);

          // Enable pan / zoom if enabled in config
          if (this.isOptionEnabled(this.config.pan_zoom)) {
            svgPanZoom($(svg)[0], {
              zoomEnabled: true,
              controlIconsEnabled: true,
              fit: true,
              center: true,
            });
          }

          return Promise.resolve(svg);
        });
    },

    loadCameraImage(imageUrl, svgElement) {
      return this.getResource(imageUrl, false, true)
        .then(imageData => {
          if ($(svgElement).attr('href') !== imageData) {
            $(svgElement).attr('href', imageData);
          }
          return Promise.resolve(imageData);
        });
    },

    loadImage(loadImageInfo) {
      let svgElementInfo = loadImageInfo.svgElementInfo;

      return this.getResource(loadImageInfo.imageUrl, true)
        .then(result => {
          let svg = $(result).find('svg')[0];
          let embeddedSvg = svg.cloneNode(true);

          $(embeddedSvg)
            .attr('id', svgElementInfo.svgElement.id)
            .attr('preserveAspectRatio', 'xMinYMin meet')
            .attr('height', svgElementInfo.bbox.height)
            .attr('width', svgElementInfo.bbox.width)
            .attr('x', svgElementInfo.bbox.x)
            .attr('y', svgElementInfo.bbox.y)
            .css('-webkit-perspective:', '1000')
            .css('-webkit-transform-style', 'preserve-3d')
            .css('-webkit-backface-visibility', 'hidden');

          $(embeddedSvg).find('*').append(document.createElementNS('http://www.w3.org/2000/svg', 'title'))
            .on('click', this.onEntityClick.bind({ instance: this, entityId: loadImageInfo.entityId, groupInfo: loadImageInfo.groupInfo }))
            .css('cursor', 'pointer')
            .addClass('ha-entity');

          // Remove previous SVG
          let $svg = $(svgElementInfo.svgElement).parents('svg');
          let previousEmbeddedSvg = $svg.find(`[id="${svgElementInfo.svgElement.id}"]`);

          let $parent = $(previousEmbeddedSvg).parent();

          $(previousEmbeddedSvg).find('*')
            .off('click');

          $(previousEmbeddedSvg)
            .off('click')
            .remove();

          $parent.append(embeddedSvg);

          svgElementInfo.svgElement = embeddedSvg;

          return Promise.resolve(embeddedSvg);
        })
    },

    /***************************************************************************************************************************/
    /* Initialization
    /***************************************************************************************************************************/

    initTimeDifference() {
      this.hass.connection.socket.addEventListener('message', event => {
        let data = JSON.parse(event.data);

        // Store the time difference between the local web browser and the Home Assistant server
        if (data.event && data.event.time_fired) {
          let lastEventFiredTime = moment(data.event.time_fired).toDate();
          this.timeDifference = moment().diff(moment(lastEventFiredTime), 'milliseconds');
        }
      });
    },

    initFullyKiosk() {
      if (this.isOptionEnabled(this.config.fully_kiosk)) {
        this.fullyKiosk = new FullyKiosk(this);
        this.fullyKiosk.init();
      }
    },

    initPageDisplay() {
      if (this.config.pages) {
        Object.keys(this.pageInfos).map(key => {
          let pageInfo = this.pageInfos[key];

          $(pageInfo.svg).css('opacity', 1);
          $(pageInfo.svg).css('display', pageInfo.isDefault ? 'initial' : 'none'); // Show the first page
        });
      }
      else {
        // Show the SVG
        $(this.config.svg).css('opacity', 1);
        $(this.config.svg).css('display', 'initial');
      }
    },

    /***************************************************************************************************************************/
    /* SVG initialization
    /***************************************************************************************************************************/

    initSvg(svg, config) {
      if (!config.groups) {
        return;
      }

      let svgElements = $(svg).find('*').toArray();

      // Add the last motion entity if required
      if (config.last_motion && config.last_motion.entity && config.last_motion.class) {
        this.lastMotionConfig = config.last_motion;

        entityInfo = { groupInfos: [], lastState: undefined };
        this.entityInfos[config.last_motion.entity] = entityInfo;
      }

      let elementGroups = config.groups.filter(x => x.elements);
      for (let elementGroup of elementGroups) {
        for (let elementId of elementGroup.elements) {
          let svgElement = $(svg).find(`[id="${elementId}"]`);

          if (svgElement.length) {
            $(svgElement).on('click', this.onElementClick.bind({ instance: this, elementId: elementId }));
            $(svgElement).css('cursor', 'pointer');

            let elementInfo = {
              group: elementGroup,
            };

            this.elementInfos[elementId] = elementInfo;

            switch (elementGroup.action.service) {
              case 'toggle':
                for (let otherElementId of elementGroup.action.data.elements) {
                  let otherSvgElement = $(svg).find(`[id="${otherElementId}"]`);
                  $(otherSvgElement).addClass(elementGroup.action.data.default_class);
                }
                break;

              default:
                break;
            }
          }
          else {
            this.logWarning(`Cannot find '${elementId}' in SVG file`);
          }
        }
      }

      let entityGroups = config.groups.filter(x => x.entities);
      for (let entityGroup of entityGroups) {
        let targetEntities = [];

        // Split out HA entity groups into separate entities
        if (entityGroup.groups) {
          for (let entityId of entityGroup.groups) {
            let group = this.hass.states[entityId];
            if (group) {
              for (let targetEntityId of group.attributes.entity_id) {
                targetEntities.push({ entityId: targetEntityId, elementId: targetEntityId });
              }
            }
            else {
              this.logWarning(`Cannot find '${entityId}' in HA group configuration`);
            }
          }
        }

        // HA entities treated as is
        if (entityGroup.entities) {
          let entityIds = entityGroup.entities.filter(x => (typeof x === 'string'));
          for (let entityId of entityIds) {
            let entity = this.hass.states[entityId];
            if (entity) {
              targetEntities.push({ entityId: entityId, elementId: entityId });
            }
            else {
              this.logWarning(`Cannot find '${entityId}' in HA group configuration`);
            }
          }

          let entityObjects = entityGroup.entities.filter(x => (typeof x !== 'string'));
          for (let entityObject of entityObjects) {
            let entity = this.hass.states[entityObject.entity];
            if (entity) {
              targetEntities.push({ entityId: entityObject.entity, elementId: entityObject.element });
            }
            else {
              this.logWarning(`Cannot find '${entityObject.entity}' in HA group configuration`);
            }
          }
        }

        for (let entityObject of targetEntities) {
          let entityId = entityObject.entityId;
          let elementId = entityObject.elementId;

          let entityInfo = this.entityInfos[entityId];
          if (!entityInfo) {
            entityInfo = { groupInfos: [], lastState: undefined };
            this.entityInfos[entityId] = entityInfo;
          }

          let groupInfo = { group: entityGroup, svgElementInfos: {}, };
          entityInfo.groupInfos.push(groupInfo);

          let svgElement = svgElements.find(svgElement => svgElement.id === elementId);
          if (!svgElement) {
            this.logWarning(`Cannot find element '${elementId}' in SVG file`);
            continue;
          }

          let originalBBox = svgElement.getBBox();

          if (entityGroup.camera_image_template) {
            svgElement = this.replaceWithImage(svgElement);
          }
          else if (entityGroup.image_template) {
            svgElement = this.replaceWithSvg(svgElement);
          }

          this.addSvgElementToGroup(svgElement, entityId, groupInfo, originalBBox);

          for (svgElementId in groupInfo.svgElementInfos) {
            let svgElementInfo = groupInfo.svgElementInfos[svgElementId];

            let $svgElement = $(svgElementInfo.svgElement);

            // Create a title element (to support hover over text)
            $svgElement.append(document.createElementNS('http://www.w3.org/2000/svg', 'title'));

            if ($svgElement.length) {
              svgElementInfo.svgElement = $svgElement[0];

              $svgElement.on('click', this.onEntityClick.bind({ instance: this, entityId: entityId, groupInfo: groupInfo }));
              $svgElement.css('cursor', 'pointer');
              $svgElement.addClass('ha-entity');

              if ($svgElement.is('text') && ($svgElement[0].id === elementId)) {
                this.addBackgroundRectToText($svgElement[0], entityId);
              }
            }
          }
        }
      }
    },

    addBackgroundRectToText(svgElement, entityId) {
      let bbox = svgElement.getBBox();

      let rect = $(document.createElementNS('http://www.w3.org/2000/svg', 'rect'))
        .attr('id', entityId + '.background')
        .attr('height', bbox.height + 1)
        .attr('width', bbox.width + 2)
        .attr('x', bbox.x - 1)
        .attr('y', bbox.y - 0.5)
        .css('fill-opacity', 0);

      $(rect).insertBefore(svgElement);
    },

    addSvgElementToGroup(svgElement, entityId, groupInfo, originalBBox) {
      groupInfo.svgElementInfos[svgElement.id] = {
        svgElement: svgElement,
        originalStroke: svgElement.style.stroke,
        originalFill: svgElement.style.fill,
        originalClasses: this.getArray(svgElement.classList),
        entityId: entityId,
        bbox: originalBBox,
      };

      this.addNestedSvgElementsToGroup(svgElement, entityId, groupInfo);
    },

    addNestedSvgElementsToGroup(svgElement, entityId, groupInfo) {
      $(svgElement).find('*').each((i, svgNestedElement) => {
        groupInfo.svgElementInfos[svgNestedElement.id] = {
          svgElement: svgNestedElement,
          originalStroke: svgNestedElement.style.stroke,
          originalFill: svgNestedElement.style.fill,
          originalClasses: this.getArray(svgNestedElement.classList),
          entityId: entityId,
        };
      });
    },

    replaceWithImage(svgElement) {
      let $parent = $(svgElement).parent();
      $(svgElement).remove();

      svgElement = $(document.createElementNS('http://www.w3.org/2000/svg', 'image'))
        .attr('id', $(svgElement).attr('id'))
        .attr('x', $(svgElement).attr('x'))
        .attr('y', $(svgElement).attr('y'))
        .attr('height', $(svgElement).attr('height'))
        .attr('width', $(svgElement).attr('width'))
        .appendTo($parent)[0];

      return svgElement;
    },

    replaceWithSvg(svgElement) {
      let $parent = $(svgElement).parent();
      let bbox = svgElement.getBBox();
      $(svgElement).remove();

      svgElement = $('<svg />')
        .attr('id', $(svgElement).attr('id'))
        .appendTo($parent)[0];

      return svgElement;
    },

    addClass(entityId, svgElement, className) {
      this.logDebug('CLASS', `${entityId} (adding class: ${className})`);

      if ($(svgElement).hasClass('ha-leave-me-alone')) {
        return;
      }

      //this.logDebug(`Adding class '${className}' to '${entityId}'`);
      if (!$(svgElement).hasClass(className)) {
        $(svgElement).addClass(className);

        if ($(svgElement).is('text')) {
          $(svgElement).parent().find(`[id="${entityId}.background"]`).each((i, rectElement) => {
            if (!$(rectElement).hasClass(className + '-background')) {
              $(rectElement).addClass(className + '-background');
            }
          });
        }
      }

      $(svgElement).find('*').each((i, svgNestedElement) => {
        if (!$(svgNestedElement).hasClass('ha-leave-me-alone')) {
          if (!$(svgNestedElement).hasClass(className)) {
            $(svgNestedElement).addClass(className);
          }
        }
      });
    },

    removeClasses(entityId, svgElement, classes) {
      for (className of classes) {
        this.logDebug('CLASS', `${entityId} (removing class: ${className})`);

        //this.logDebug(`Removing class '${className}' from '${entityId}'`);
        if ($(svgElement).hasClass(className)) {
          $(svgElement).removeClass(className);

          if ($(svgElement).is('text')) {
            $(svgElement).parent().find(`[id="${entityId}.background"]`).each((i, rectElement) => {
              if ($(rectElement).hasClass(className + '-background')) {
                $(rectElement).removeClass(className + '-background');
              }
            });
          }

          $(svgElement).find('*').each((i, svgNestedElement) => {
            if ($(svgNestedElement).hasClass(className)) {
              $(svgNestedElement).removeClass(className);
            }
          });
        }
      }
    },

    setEntityStyle(svgElementInfo, svgElement, entityInfo, groupInfo) {
      let stateConfig = groupInfo.group.states.find(stateConfig => (stateConfig.state === entityInfo.lastState.state));
      if (stateConfig) {
        let stroke = this.getStroke(stateConfig);
        if (stroke) {
          svgElement.style.stroke = stroke;
        }
        else {
          if (svgElementInfo.originalStroke) {
            svgElement.style.stroke = svgElementInfo.originalStroke;
          }
          else {
            // ???
          }
        }

        let fill = this.getFill(stateConfig);
        if (fill) {
          svgElement.style.fill = fill;
        }
        else {
          if (svgElementInfo.originalFill) {
            svgElement.style.fill = svgElementInfo.originalFill;
          }
          else {
            // ???
          }
        }
      }
    },

    /***************************************************************************************************************************/
    /* Entity handling (when states change)
    /***************************************************************************************************************************/

    handleEntities(entities, isInitialLoad) {
      let changedEntityIds = this.getChangedEntities(entities, isInitialLoad);
      if (changedEntityIds && changedEntityIds.length) {
        let promises = changedEntityIds.map(entityId => this.handleEntity(entityId, entities, isInitialLoad));
        return Promise.all(promises)
          .then(() => {
            return Promise.resolve(changedEntityIds);
          });
      }
    },

    getChangedEntities(entities, isInitialLoad) {
      let changedEntityIds = [];

      let entityIds = Object.keys(entities);

      let lastMotionEntityInfo, oldLastMotionState, newLastMotionState;

      if (this.lastMotionConfig) {
        lastMotionEntityInfo = this.entityInfos[this.lastMotionConfig.entity];
        if (lastMotionEntityInfo && lastMotionEntityInfo.lastState) {
          oldLastMotionState = lastMotionEntityInfo.lastState.state;
          newLastMotionState = entities[this.lastMotionConfig.entity].state;
        }
      }

      for (let entityId of entityIds) {
        let entityInfo = this.entityInfos[entityId];
        if (entityInfo) {
          let entityState = entities[entityId];

          if (isInitialLoad) {
            this.logDebug('STATE', `${entityId}: ${entities[entityId].state} (initial load)`);
            if (changedEntityIds.indexOf(entityId) < 0) {
              changedEntityIds.push(entityId);
            }
          }
          else if (entityInfo.lastState) {
            let oldState = entityInfo.lastState.state;
            let newState = entityState.state;

            if (entityState.last_changed !== entityInfo.lastState.last_changed) {
              this.logDebug('STATE', `${entityId}: ${newState} (last changed ${moment(entityInfo.lastState.last_changed).format("DD-MMM-YYYY HH:mm:ss")})`);
              if (changedEntityIds.indexOf(entityId) < 0) {
                changedEntityIds.push(entityId);
              }
            }
            else {
              let oldAttributesText = JSON.stringify(entityInfo.lastState.attributes);
              let newAttributesText = JSON.stringify(entityState.attributes);

              if (newAttributesText !== oldAttributesText) {
                if (entityId.indexOf('media_player') < 0) {
                  this.logDebug('STATE', `${entityId}: attributes (last updated ${moment(entityInfo.lastState.last_changed).format("DD-MMM-YYYY HH:mm:ss")})`);
                  if (changedEntityIds.indexOf(entityId) < 0) {
                    changedEntityIds.push(entityId);
                  }
                }
              }
            }

            if (this.lastMotionConfig) {
              if ((newLastMotionState !== oldLastMotionState) && (entityId.indexOf('binary_sensor') >= 0)) {
                let friendlyName = entityState.attributes.friendly_name;

                if (friendlyName === newLastMotionState) {
                  this.logDebug('LAST_MOTION', `${entityId} (new)`);
                  if (changedEntityIds.indexOf(entityId) < 0) {
                    changedEntityIds.push(entityId);
                  }
                }
                else if (friendlyName === oldLastMotionState) {
                  this.logDebug('LAST_MOTION', `${entityId} (old)`);
                  if (changedEntityIds.indexOf(entityId) < 0) {
                    changedEntityIds.push(entityId);
                  }
                }
              }
            }
          }
        }
      }

      return changedEntityIds;
    },

    handleEntity(entityId, entities, isInitialLoad) {
      let entityState = entities[entityId];
      let entityInfo = this.entityInfos[entityId];

      entityInfo.lastState = Object.assign({}, entityState);

      return this.handleEntityUpdateDom(entityId, entities)
        .then(() => {
          this.handleEntityUpdateCss(entityId, entities, isInitialLoad)
          this.handleEntityUpdateLastMotionCss(entityId, entities);
          this.handleEntitySetHoverOver(entityId, entities);
        });
    },

    handleEntityUpdateDom(entityId, entities) {
      let loadImagePromises = [];

      let entityState = entities[entityId];
      let entityInfo = this.entityInfos[entityId];

      for (let groupInfo of entityInfo.groupInfos) {
        for (let svgElementId in groupInfo.svgElementInfos) {
          let svgElementInfo = groupInfo.svgElementInfos[svgElementId];

          if ($(svgElementInfo.svgElement).is('text')) {
            this.handleEntityUpdateText(entityState, groupInfo, svgElementInfo, entities);
          }
          else if (groupInfo.group.camera_image_template) {
            this.handleEntityUpdateCameraImage(entityState, groupInfo, svgElementInfo, entities);
          }
          else if (groupInfo.group.image_template) {
            let loadImageInfo = this.handleEntityDetermineSvgImage(entityState, groupInfo, svgElementInfo, entities);
            if (loadImageInfo) {
              loadImagePromises.push(this.loadImage(loadImageInfo));
            }
          }
        }
      }

      return loadImagePromises.length ? Promise.all(loadImagePromises) : Promise.resolve();
    },

    handleEntityUpdateText(entityState, groupInfo, svgElementInfo, entities) {
      let svgElement = svgElementInfo.svgElement;

      let text = groupInfo.group.text_template ?
        this.evaluate(groupInfo.group.text_template, entityState, entities) : entityState.state;

      let tspan = $(svgElement).find('tspan');
      if (tspan.length) {
        $(tspan).text(text);
      }
      else {
        let title = $(svgElement).find('title');
        $(svgElement).text(text);
        if (title.length) {
          $(svgElement).append(title);
        }
      }

      let rect = $(svgElement).parent().find(`[id="${entityState.entity_id}.background"]`);
      if (rect.length) {
        let bbox = svgElement.getBBox();
        $(rect)
          .attr('x', bbox.x - 1)
          .attr('y', bbox.y - 0.5)
          .attr('height', bbox.height + 1)
          .attr('width', bbox.width + 2)
          .height(bbox.height + 1)
          .width(bbox.width + 2);
      }
    },

    handleEntityUpdateCameraImage(entityState, groupInfo, svgElementInfo, entities) {
      let svgElement = svgElementInfo.svgElement;

      imageUrl = this.evaluate(groupInfo.group.camera_image_template, entityState, entities);
      if (imageUrl && (groupInfo.imageUrl !== imageUrl)) {
        groupInfo.imageUrl = imageUrl;

        if (groupInfo.cameraImageLoader) {
          clearInterval(groupInfo.cameraImageLoader);
        }

        this.loadCameraImage(imageUrl, svgElement)
          .catch(error => {
            this.handleError(error);
          });

        if (groupInfo.group.refresh_interval) {
          let refreshInterval = parseInt(groupInfo.group.refresh_interval);

          groupInfo.cameraImageLoader = setInterval((imageUrl, svgElement) => {
            this.loadCameraImage(imageUrl, svgElement)
              .catch(error => {
                this.handleError(error);
              });
          }, refreshInterval * 1000, imageUrl, svgElement);
        }
      }
    },

    handleEntityDetermineSvgImage(entityState, groupInfo, svgElementInfo, entities) {
      imageUrl = this.evaluate(groupInfo.group.image_template, entityState, entities);
      if (groupInfo.imageUrl !== imageUrl) {
        groupInfo.imageUrl = imageUrl;

        return {
          svgElementInfo: svgElementInfo,
          imageUrl: imageUrl,
          entityId: entityState.entity_id,
          entityState: entityState,
          groupInfo: groupInfo,
        };
      }

      return undefined;
    },

    handleEntitySetHoverOver(entityId, entities) {
      let entityState = entities[entityId];
      let entityInfo = this.entityInfos[entityId];

      for (let groupInfo of entityInfo.groupInfos) {
        for (let svgElementId in groupInfo.svgElementInfos) {
          let svgElementInfo = groupInfo.svgElementInfos[svgElementId];

          this.handlEntitySetHoverOverText(svgElementInfo.svgElement, entityState);
        }
      }
    },

    handlEntitySetHoverOverText(element, entityState) {
      let dateFormat = this.config.date_format ? this.config.date_format : 'DD-MMM-YYYY';

      $(element).find('title').each((i, titleElement) => {
        let lastChangedElapsed = moment().to(moment(entityState.last_changed));
        let lastChangedDate = moment(entityState.last_changed).format(dateFormat);
        let lastChangedTime = moment(entityState.last_changed).format('HH:mm:ss');

        let lastUpdatedElapsed = moment().to(moment(entityState.last_updated));
        let lastUpdatedDate = moment(entityState.last_updated).format(dateFormat);
        let lastUpdatedTime = moment(entityState.last_updated).format('HH:mm:ss');

        let titleText = `${entityState.attributes.friendly_name}\n`;
        titleText += `State: ${entityState.state}\n\n`;

        Object.keys(entityState.attributes).map(key => {
          titleText += `${key}: ${entityState.attributes[key]}\n`;
        });
        titleText += '\n';

        titleText += `Last changed: ${lastChangedDate} ${lastChangedTime}\n`;
        titleText += `Last updated: ${lastUpdatedDate} ${lastUpdatedTime}`;

        $(titleElement).html(titleText);
      });
    },

    handleEntityUpdateCss(entityId, entities, isInitialLoad) {
      if (!this.cssRules || !this.cssRules.length) {
        return;
      }

      let entityState = entities[entityId];
      let entityInfo = this.entityInfos[entityId];

      for (let groupInfo of entityInfo.groupInfos) {
        for (let svgElementId in groupInfo.svgElementInfos) {
          let svgElementInfo = groupInfo.svgElementInfos[svgElementId];
          let svgElement = svgElementInfo.svgElement;

          let hasTransitionConfig = false;
          let wasTransitionApplied = false;

          if (groupInfo.group.states && groupInfo.group.state_transitions) {
            hasTransitionConfig = true;
            let transitionConfig = groupInfo.group.state_transitions.find(transitionConfig => (transitionConfig.to_state === entityState.state));
            if (transitionConfig && transitionConfig.from_state && transitionConfig.to_state && transitionConfig.duration) {
              let elapsed = Math.max(moment().diff(moment(entityState.last_changed), 'milliseconds'), 0);
              let remaining = (transitionConfig.duration * 1000) - elapsed;

              let fromStateConfig = groupInfo.group.states.find(stateConfig => (stateConfig.state === transitionConfig.from_state));
              let toStateConfig = groupInfo.group.states.find(stateConfig => (stateConfig.state === transitionConfig.to_state));

              let fromColor = this.getFill(fromStateConfig);
              let toColor = this.getFill(toStateConfig);

              if (fromColor && toColor) {
                if (remaining > 0) {
                  let transition = this.entityTransitions[entityId];
                  if (!transition) {
                    this.logDebug('TRANSITION', `${entityId} (created)`);
                    transition = {
                      entityId: entityId,
                      svgElementInfo: svgElementInfo,
                      groupInfo: groupInfo,
                      duration: transitionConfig.duration,
                      fromStateConfig: fromStateConfig,
                      toStateConfig: toStateConfig,
                      fromColor: fromColor,
                      toColor: toColor,
                      startMoment: undefined,
                      endMoment: undefined,
                      isActive: false,
                    };
                    this.entityTransitions[entityId] = transition;
                  }

                  // Assume the transition starts (or started) when the origin state change occurred
                  transition.startMoment = this.serverToLocalMoment(moment(entityState.last_changed));
                  transition.endMoment = transition.startMoment.clone();
                  transition.endMoment.add(transition.duration, 'seconds');

                  // If the transition is not currently running, kick it off
                  if (!transition.isActive) {
                    // If this state change just occurred, the transition starts as of now
                    if (!isInitialLoad) {
                      let nowMoment = moment();
                      transition.startMoment = nowMoment.clone();
                      transition.endMoment = transition.startMoment.clone();
                      transition.endMoment.add(transition.duration, 'seconds');
                    }

                    this.logDebug('TRANSITION', `${transition.entityId}: (start)`);
                    transition.isActive = true;
                    this.handleEntityTransition(transition);
                  }
                  else {
                    // If the transition is currently running, it will be extended with latest start / end times
                    this.logDebug('TRANSITION', `${transition.entityId} (continue)`);
                  }
                }
                else {
                  this.setEntityStyle(svgElementInfo, svgElement, entityInfo, groupInfo);
                }
              }
              else {
                this.setEntityStyle(svgElementInfo, svgElement, entityInfo, groupInfo);
              }
              wasTransitionApplied = true;
            }
          }

          let targetClass = undefined;
          let obsoleteClasses = [];

          if (groupInfo.group.class_template) {
            targetClass = this.evaluate(groupInfo.group.class_template, entityState, entities);
          }

          // Get the config for the current state
          if (groupInfo.group.states) {
            let stateConfig = groupInfo.group.states.find(stateConfig => (stateConfig.state === entityState.state));
            if (stateConfig && stateConfig.class && !wasTransitionApplied) {
              targetClass = stateConfig.class;
            }

            // Remove any other previously-added state classes
            for (let otherStateConfig of groupInfo.group.states) {
              if (!stateConfig || (otherStateConfig.state !== stateConfig.state)) {
                if (otherStateConfig.class && (otherStateConfig.class !== 'ha-entity') && $(svgElement).hasClass(otherStateConfig.class)) {
                  if (svgElementInfo.originalClasses.indexOf(otherStateConfig.class) < 0) {
                    obsoleteClasses.push(otherStateConfig.class);
                  }
                }
              }
            }
          }
          else {
            for (let otherClassName of this.getArray(svgElement.classList)) {
              if ((otherClassName !== targetClass) && (otherClassName !== 'ha-entity')) {
                if (svgElementInfo.originalClasses.indexOf(otherClassName) < 0) {
                  obsoleteClasses.push(otherClassName);
                }
              }
            }
          }

          // Remove any obsolete classes from the entity
          if (obsoleteClasses.length) {
            //this.logDebug(`${entityId}: Removing obsolete classes: ${obsoleteClasses.join(', ')}`);
            this.removeClasses(entityId, svgElement, obsoleteClasses);
          }

          // Add the target class to the entity
          if (targetClass) {
            if (hasTransitionConfig && !wasTransitionApplied) {
              let transition = this.entityTransitions[entityId];
              if (transition && transition.isActive) {
                this.logDebug('TRANSITION', `${transition.entityId} (cancel)`);
                transition.isActive = false;
              }
            }

            this.addClass(entityId, svgElement, targetClass);
          }
        }
      }
    },

    handleEntityTransition(transition) {
      if (!transition.isActive) {
        return;
      }

      let nowMoment = moment();

      let isExpired = (nowMoment >= transition.endMoment);

      let ratio = isExpired ? 1 : (nowMoment - transition.startMoment) / (transition.endMoment - transition.startMoment);
      let color = this.getTransitionColor(transition.fromColor, transition.toColor, ratio);
      //this.logDebug('TRANSITION', `${transition.entityId} (ratio: ${ratio}, element: ${transition.svgElementInfo.svgElement.id}, fill: ${color})`);
      transition.svgElementInfo.svgElement.style.fill = color;

      if (isExpired) {
        transition.isActive = false;
        this.logDebug('TRANSITION', `${transition.entityId} (end)`);
        return;
      }

      setTimeout(() => {
        this.handleEntityTransition(transition);
      }, 100);
    },

    handleEntityUpdateLastMotionCss(entityId, entities) {
      if (!this.lastMotionConfig || !this.cssRules || !this.cssRules.length) {
        return;
      }

      let entityState = entities[entityId];
      let entityInfo = this.entityInfos[entityId];

      for (let groupInfo of entityInfo.groupInfos) {
        for (let svgElementId in groupInfo.svgElementInfos) {
          let svgElementInfo = groupInfo.svgElementInfos[svgElementId];
          let svgElement = svgElementInfo.svgElement;

          if (entities[this.lastMotionConfig.entity] &&
            (entityState.attributes.friendly_name === entities[this.lastMotionConfig.entity].state)) {
            if (!$(svgElement).hasClass(this.lastMotionConfig.class)) {
              //this.logDebug(`${entityId}: Adding last motion class '${this.lastMotionConfig.class}'`);
              $(svgElement).addClass(this.lastMotionConfig.class);
            }
          }
          else {
            if ($(svgElement).hasClass(this.lastMotionConfig.class)) {
              //this.logDebug(`${entityId}: Removing last motion class '${this.lastMotionConfig.class}'`);
              $(svgElement).removeClass(this.lastMotionConfig.class);
            }
          }
        }
      }
    },

    /***************************************************************************************************************************/
    /* Floorplan helper functions
    /***************************************************************************************************************************/

    isOptionEnabled(option) {
      return ((option === null) || (option !== undefined));
    },

    isLastMotionEnabled() {
      return this.lastMotionConfig && this.config.last_motion.entity && this.config.last_motion.class;
    },

    validateConfig(config) {
      let isValid = true;

      if (!config.pages && !config.groups) {
        this.isLoading = false;
        this.logWarning(`Cannot find 'pages' nor 'groups' in floorplan configuration`);
        isValid = false;
      }
      else {
        if (config.pages) {
          if (!config.pages.length) {
            this.logWarning(`The 'pages' section must contain one or more pages in floorplan configuration`);
            isValid = false;
          }
        }
        else {
          if (!config.groups) {
            this.logWarning(`Cannot find 'groups' in floorplan configuration`);
            isValid = false;
          }

          let invalidGroups = config.groups.filter(x => x.entities && x.elements);
          if (invalidGroups.length) {
            this.logWarning(`A group cannot contain both 'entities' and 'elements' in floorplan configuration`);
            isValid = false;
          }

          invalidGroups = config.groups.filter(x => !x.entities && !x.elements);
          if (invalidGroups.length) {
            this.logWarning(`A group must contain either 'entities' or 'elements' in floorplan configuration`);
            isValid = false;
          }
        }
      }

      return isValid;
    },

    localToServerMoment(localMoment) {
      let serverMoment = localMoment.clone();
      if (this.timeDifference >= 0)
        serverMoment.subtract(this.timeDifference, 'milliseconds');
      else
        serverMoment.add(Math.abs(this.timeDifference), 'milliseconds');
      return serverMoment;
    },

    serverToLocalMoment(serverMoment) {
      let localMoment = serverMoment.clone();
      if (this.timeDifference >= 0)
        localMoment.add(Math.abs(this.timeDifference), 'milliseconds');
      else
        localMoment.subtract(this.timeDifference, 'milliseconds');
      return localMoment;
    },

    evaluate(code, entity, entities) {
      let functionBody = (code.indexOf('return') >= 0) ? code : `return \`${code}\`;`;
      let func = new Function('entity', 'entities', 'hass', 'config', functionBody);
      return func(entity, entities, this.hass, this.config);
    },

    /***************************************************************************************************************************/
    /* Event handlers
    /***************************************************************************************************************************/

    onElementClick(e) {
      let svgElement = e.target;

      let svg = $(svgElement).parents('svg');

      let elementInfo = this.instance.elementInfos[this.elementId];
      if (elementInfo.group.action) {
        let action = elementInfo.group.action;
        if (action.service) {
          switch (action.domain) {
            case 'class':
              switch (action.service) {
                case 'toggle':
                  let classes = action.data.classes;

                  for (let otherElementId of action.data.elements) {
                    let otherSvgElement = $(svg).find(`[id="${otherElementId}"]`);

                    if ($(otherSvgElement).hasClass(classes[0])) {
                      $(otherSvgElement).removeClass(classes[0]);
                      $(otherSvgElement).addClass(classes[1]);
                    }
                    else if ($(otherSvgElement).hasClass(classes[1])) {
                      $(otherSvgElement).removeClass(classes[1]);
                      $(otherSvgElement).addClass(classes[0]);
                    }
                    else {
                      $(otherSvgElement).addClass(action.data.default_class);
                    }
                  }
                  break;

                default:
                  this.instance.callService(action);
                  break;
              }

            case 'page':
              switch (action.service) {
                case 'navigate':
                  let page_id = action.data.page_id;
                  let targetPageInfo = page_id && this.instance.pageInfos[page_id];

                  if (targetPageInfo) {
                    Object.keys(this.instance.pageInfos).map(key => {
                      let pageInfo = this.instance.pageInfos[key];

                      if ($(pageInfo.svg).css('display') !== 'none') {
                        $(pageInfo.svg).css('display', 'none');
                      }
                    });

                    $(targetPageInfo.svg).css('display', 'initial');
                  }
                  break;
              }
          }
        }
      }
    },

    onEntityClick(e) {
      let entityId = this.entityId;
      let groupInfo = this.groupInfo;

      if (groupInfo.group.action) {
        let action = groupInfo.group.action;
        if (action.service) {
          this.instance.callService(action, entityId);
        }
        else {
          this.instance.fire('hass-more-info', { entityId: entityId });
        }
      }
      else {
        this.instance.fire('hass-more-info', { entityId: entityId });
      }
    },

    /***************************************************************************************************************************/
    /* Home Assisant helper functions
    /***************************************************************************************************************************/

    callService(action, entityId) {
      let domain = action.domain ? action.domain : window.HAWS.extractDomain(entityId);
      domain = (domain === 'group') ? 'homeassistant' : domain;

      let data = action.data ? action.data : {};

      if (action.data_template) {
        let entities = this.hass.states;
        let entityState = entities[entityId];
        let result = this.evaluate(action.data_template, entityState, entities);
        data = JSON.parse(result);
      }

      if (!data.entity_id) {
        data['entity_id'] = entityId;
      }

      this.hass.callService(domain, action.service, data);
    },

    /***************************************************************************************************************************/
    /* Logging / error handling functions
    /***************************************************************************************************************************/

    handleWindowError(msg, url, lineNo, columnNo, error) {
      this.isLoading = false;

      if (msg.toLowerCase().indexOf("script error") >= 0) {
        this.logError('Script error: See browser console for detail');
      }
      else {
        let message = [
          msg,
          'URL: ' + url,
          'Line: ' + lineNo + ', column: ' + columnNo,
          'Error: ' + JSON.stringify(error)
        ].join('<br>');

        this.logError(message);
      }

      return false;
    },

    handleError(error) {
      let message = error;
      if (error.stack) {
        message = `${error.stack}`;
      }
      else if (error.message) {
        message = `${error.message}`;
      }

      this.log('error', message);
    },

    logError(message) {
      this.log('error', message);
    },

    logWarning(message) {
      this.log('warning', message);
    },

    logInfo(message) {
      this.log('info', message);
    },

    logDebug(area, message) {
      this.log('debug', `${area} ${message}`);
    },

    log(level, message) {
      let text = `${moment().format("DD-MM-YYYY HH:mm:ss")} ${level.toUpperCase()} ${message}`;
      console.log(text);

      if (!this.config) {
        // Always log messages before the config has been loaded
      }
      else if (!this.logLevels || !this.logLevels.length || (this.logLevels.indexOf(level) < 0)) {
        return;
      }

      let log = Polymer.dom(this.$.log).node;
      $(log).find('ul').prepend(`<li class="${level}">${text}</li>`)
      $(log).css('display', 'block');
    },

    /***************************************************************************************************************************/
    /* CSS helper functions
    /***************************************************************************************************************************/

    getStroke(stateConfig) {
      let stroke = undefined;

      for (let cssRule of this.cssRules) {
        if (cssRule.selectorText && cssRule.selectorText.indexOf(`.${stateConfig.class}`) >= 0) {
          if (cssRule.style && cssRule.style.stroke) {
            if (cssRule.style.stroke[0] === '#') {
              stroke = cssRule.style.stroke;
            }
            else {
              let rgb = cssRule.style.stroke.substring(4).slice(0, -1).split(',').map(x => parseInt(x));
              stroke = `#${rgb[0].toString(16)[0]}${rgb[1].toString(16)[0]}${rgb[2].toString(16)[0]}`;
            }
          }
        }
      }

      return stroke;
    },

    getFill(stateConfig) {
      let fill = undefined;

      for (let cssRule of this.cssRules) {
        if (cssRule.selectorText && cssRule.selectorText.indexOf(`.${stateConfig.class}`) >= 0) {
          if (cssRule.style && cssRule.style.fill) {
            if (cssRule.style.fill[0] === '#') {
              fill = cssRule.style.fill;
            }
            else {
              let rgb = cssRule.style.fill.substring(4).slice(0, -1).split(',').map(x => parseInt(x));
              fill = `#${rgb[0].toString(16)}${rgb[1].toString(16)}${rgb[2].toString(16)}`;
            }
          }
        }
      }

      return fill;
    },

    getTransitionColor(fromColor, toColor, value) {
      return (value <= 0) ? fromColor :
        ((value >= 1) ? toColor : this.rgbToHex(this.mix(this.hexToRgb(toColor), this.hexToRgb(fromColor), value)));
    },

    loadStyleSheetInternal(path, fn, scope) {
      let head = document.getElementsByTagName('head')[0]; // reference to document.head for appending / removing link nodes
      let link = document.createElement('link');           // create the link node
      link.setAttribute('href', this.cacheBuster(path));
      link.setAttribute('rel', 'stylesheet');
      link.setAttribute('type', 'text/css');

      let sheet, cssRules;
      // get the correct properties to check for depending on the browser
      if ('sheet' in link) {
        sheet = 'sheet'; cssRules = 'cssRules';
      }
      else {
        sheet = 'styleSheet'; cssRules = 'rules';
      }

      let intervalId = setInterval(function () {                     // start checking whether the style sheet has successfully loaded
        try {
          if (link[sheet] && link[sheet][cssRules].length) { // SUCCESS! our style sheet has loaded
            clearInterval(intervalId);                      // clear the counters
            clearTimeout(timeoutId);
            fn.call(scope || window, true, link);           // fire the callback with success == true
          }
        }
        catch (e) { debugger; }
        finally { }
      }, 10),                                               // how often to check if the stylesheet is loaded
        timeoutId = setTimeout(function () {                // start counting down till fail
          clearInterval(intervalId);                        // clear the counters
          clearTimeout(timeoutId);
          head.removeChild(link);                           // since the style sheet didn't load, remove the link node from the DOM
          fn.call(scope || window, false, link);            // fire the callback with success == false
        }, 15000);                                          // how long to wait before failing

      head.appendChild(link);  // insert the link node into the DOM and start loading the style sheet

      return link; // return the link node
    },

    /***************************************************************************************************************************/
    /* General helper functions
    /***************************************************************************************************************************/

    getResource(resourceUrl, useCache, isImage) {
      resourceUrl = this.cacheBuster(resourceUrl);
      useCache = false;

      return new Promise((resolve, reject) => {
        let options = {
          url: resourceUrl,
          cache: (useCache === true),
          //processData: false,
          error: (err) => {
            reject(new URIError(`${resourceUrl}: ${err.responseText}`));
          },
          success: (result) => {
            resolve(isImage ? `data:image/jpeg;base64,${this.base64Encode(result)}` : result);
          },
        };

        if (isImage) {
          options.mimeType = 'text/plain; charset=x-user-defined';
        }

        jQuery.ajax(options);
      });
    },

    /***************************************************************************************************************************/
    /* Utility functions
    /***************************************************************************************************************************/

    getArray(list) {
      return Array.isArray(list) ? list : Object.keys(list).map(key => list[key]);
    },

    base64Encode(str) {
      let CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      let out = "", i = 0, len = str.length, c1, c2, c3;
      while (i < len) {
        c1 = str.charCodeAt(i++) & 0xff;
        if (i === len) {
          out += CHARS.charAt(c1 >> 2);
          out += CHARS.charAt((c1 & 0x3) << 4);
          out += "==";
          break;
        }
        c2 = str.charCodeAt(i++);
        if (i === len) {
          out += CHARS.charAt(c1 >> 2);
          out += CHARS.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));
          out += CHARS.charAt((c2 & 0xF) << 2);
          out += "=";
          break;
        }
        c3 = str.charCodeAt(i++);
        out += CHARS.charAt(c1 >> 2);
        out += CHARS.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));
        out += CHARS.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6));
        out += CHARS.charAt(c3 & 0x3F);
      }
      return out;
    },

    cacheBuster(url) {
      return `${url}${(url.indexOf('?') >= 0) ? '&' : '?'}_=${new Date().getTime()}`;
    },

    debounce(func, wait, immediate) {
      let timeout;
      return function () {
        let context = this, args = arguments;

        let later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        let callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);

        if (callNow) func.apply(context, args);
      };
    },

    /***************************************************************************************************************************/
    /* Color functions
    /***************************************************************************************************************************/

    rgbToHex(rgb) {
      return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
    },

    hexToRgb(hex) {
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, (m, r, g, b) => {
        return r + r + g + g + b + b;
      });

      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    },

    mix(color1, color2, weight) {
      let p = weight;
      let w = p * 2 - 1;
      let w1 = ((w / 1) + 1) / 2;
      let w2 = 1 - w1;
      let rgb = [
        Math.round(color1.r * w1 + color2.r * w2),
        Math.round(color1.g * w1 + color2.g * w2),
        Math.round(color1.b * w1 + color2.b * w2)
      ];
      return rgb;
    },
  });

</script>
